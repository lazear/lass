#encoder.py
#shout out to x86asm.net for the extremely helpful opcode tables
c = \
''' /* This file was generated by encoder.py as part of lass - the lightweight assembler
(C) 2016 Michael Lazear*/
#ifndef __LASS_ISA__
#define __LASS_ISA__

typedef struct _instruction_set {
	char name[10];
	int op1;
	int op2;
	int primary;
	int extension;
	int secondary;
	int prefix;
} isa;

#define none	0
#define r32 	0x10
#define rm32 	r32
#define r8 		0x20
#define rm8		r8
#define imm8 	0x40
#define imm32	0x80
#define crn 	0x100
#define rel8 	0x200
#define rel32 	0x400
#define eax 	r32 | EAX | 0x800 	// So this value doesn't get used
#define edx 	r32 | EDX
#define ecx		r32 | ECX
#define ebx		r32 | EBX
#define sreg	0x1000
#define ss 		sreg | 2
#define cs 		sreg | 1
#define ds 		sreg | 3
#define es 		sreg | 0
#define fs 		sreg | 4
#define gs 		sreg | 5

'''
good = ["sreg", "rel8", "rel32", "r8", "r32", "crn", "r16", "rm8", "rm16", "rm32", \
"imm8", "imm16", "imm32", "eax", "ecx", "edx", "none", "", "ds", "es", "fs", \
"gs", "cs", "ss", "m"]
bad = ["xmm", "xmm/m128", "mm"]

not_really_operands = [ "1", "flags", "eflags"]


# Things that don't really have operands
white_list = ["stos", "stosb", "stosw", "stosd", "sysenter", "sysexit", "pusha", "popa", "pushad", "popad"]
one_args = ["lidt", "lgdt", "sidt", "sgdt", "div", "mul"]

with open("opcodes.h", "w") as o:
	o.write(c)
	with open("opcodes.csv", "r") as f:
		o.write("isa x86[] = {\n")
		last = []
		for line in f:
			line = line.lower()
			line = line.replace("r/m", "rm")
			line = line.replace("16/32", "32")
			line = line.replace("16", "32")
			line = line.split(',')
			line = ["" if x in not_really_operands else x for x in line]
			#print(line)
			name = line[0]		# instruction name
			op1 = line[1]		# operand 1 type
			op2 = line[2]		# operand 2 type
			#print(line[3])
			pf = line[6]		# extraordinary prefix
			of = line[7]		# dedicated 0Fh prefix
			code = line[8]		# preimary opcode
			ext = line[10]
			if code and code != "po":
				if "+r" in code:
					op2 = op2 if op2 else "none"
					ext = "DEAD"
					code = code.split("+")[0]
				if ext:
					if ext == 'r':
						ext = "0x0"
					else:
						ext = '0x' + ext
				else:
					ext= "0x0"
		
				pf = pf if pf else "0"
				of = of if of else "0"

				if name in one_args:
					print(line)
					op1 = "rm32" if "rm32" in line else "rm8"
					op2 = "none" 
				if name in white_list:
					op1 = "none"
					op2 = "none"
				op1 = "none" if op1 == "" else op1
				op2 = "none" if op2 == "" else op2

				if "rm" in op1 and "r" in op2 and name != "test":
					continue
				if op1 in good and op2 in good:
					o.write("\t{\"" + name.lower() + "\", " + op1.lower() + ", " + op2.lower() + ", 0x" + code + ", " + ext + ", 0x" + pf + ", 0x" + of + "},\n")
					last = [name.lower(), op1, op2, code, ext, pf, of]

				#elif op1 not in bad and op2 not in bad:
				#	print("\t{\"" + name.lower() + "\", " + op1.lower() + ", " + op2.lower() + ", 0x" + code + ", " + ext + ", 0x" + pf + ", 0x" + of + "}")
			else:
				print(line)
				if last:
					last[0] = name
					o.write("\t{\"" + last[0] + "\", " + last[1]  + ", " + last[2]  + ", 0x" + last[3]  + ", " + last[4]  + ", 0x" + last[5]  + ", 0x" + last[6]  + "},\n")
					

	o.write("};\n#endif")
