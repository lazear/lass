#encoder.py
#shout out to x86asm.net for the extremely helpful opcode tables
c = \
''' /* This file was generated by encoder.py as part of lass - the lightweight assembler
(C) 2016 Michael Lazear*/
#ifndef __LASS_ISA__
#define __LASS_ISA__

typedef struct _instruction_set {
	char name[10];
	char op1[10];
	char op2[10];
	int primary;
	int extension;
	int secondary;
	int prefix;
} isa;\n
'''
with open("opcodes.h", "w") as o:
	o.write(c)
	with open("opcodes.csv", "r") as f:
		o.write("isa x86[] = {\n")
		for line in f:
			line = line.replace("r/m", "rm")
			line = line.replace("16/32", "32")
			line = line.split(',')

			name = line[0]		# instruction name
			op1 = line[1]		# operand 1 type
			op2 = line[2]		# operand 2 type
			pf = line[6]		# extraordinary prefix
			of = line[7]		# dedicated 0Fh prefix
			code = line[8]		# preimary opcode
			ext = line[10]
			if code and code != "po":
				if "+r" in code:
					op2 = op2 if op2 else "X"
					code = code.split("+")[0]
				if ext:
					if ext == 'r':
						ext = '0xFF'
					else:
						ext = '0x' + ext
				else:
					ext= '0x0'
				pf = pf if pf else "0"
				of = of if of else "0"
				o.write("\t{\"" + name.lower() + "\", \"" + op1.lower() + "\", \"" + op2.lower() + "\", 0x" + code + ", " + ext + ", 0x" + pf + ", 0x" + of + "},\n")
	o.write("};\n#endif")
